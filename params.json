{"name":"Contracts.ruby","tagline":"Contracts for Ruby","body":"# The contracts.ruby tutorial\r\n\r\n## Introduction\r\n\r\ncontracts.ruby brings code contracts to the Ruby language. Code contracts allow you make some assertions about your code, and then checks them to make sure they hold. This lets you\r\n\r\n- catch bugs faster\r\n- make it very easy to catch certain types of bugs\r\n- make sure that the user gets proper messaging when a bug occurs.\r\n\r\n## Installation\r\n\r\n    gem install contracts\r\n\r\n## Basics\r\n\r\nA simple example:\r\n\r\n```ruby\r\nContract Contracts::Num, Contracts::Num => Contracts::Num\r\ndef add(a, b)\r\n  a + b\r\nend\r\n```\r\n\r\nHere, the contract is `Contract Num, Num => Num`. This says that the `add` function takes two numbers and returns a number.\r\n\r\nCopy this code into a file and run it:\r\n\r\n```ruby\r\nrequire 'contracts'\r\n\r\nclass Math\r\n  include Contracts::Core\r\n\r\n  Contract Contracts::Num, Contracts::Num => Contracts::Num\r\n  def self.add(a, b)\r\n    a + b\r\n  end\r\nend\r\n\r\nputs Math.add(1, \"foo\")\r\n```\r\n\r\nYou'll see a detailed error message like so:\r\n\r\n    ./contracts.rb:60:in `failure_callback': Contract violation: (RuntimeError)\r\n        Expected: Contracts::Num,\r\n        Actual: \"foo\"\r\n        Value guarded in: Object::add\r\n        With Contract: Contracts::Num, Contracts::Num\r\n        At: foo.rb:6\r\n\r\nThat tells you that your contract was violated! `add` expected a `Num`, and got a string (`\"foo\"`) instead.\r\nBy default, an exception is thrown when a contract fails. This can be changed to do whatever you want. More on this later.\r\n\r\nYou can also see the contract for a function with the `functype` method:\r\n\r\n    functype(:add)\r\n    => \"add :: Num, Num => Num\"\r\n\r\nThis can be useful if you're in a REPL and want to figure out how a function should be used.\r\n\r\n## Built-in Contracts\r\n\r\n`Num` is one of the built-in contracts that contracts.ruby comes with. The built-in contracts are in the `Contracts` namespace. The easiest way to use them is to include the `Contracts::Builtin` module in your class/module.\r\n\r\ncontracts.ruby comes with a lot of built-in contracts, including the following:\r\n\r\n* Basic types\r\n  * [`Num`](http://www.rubydoc.info/gems/contracts/Contracts/Num) – checks that the argument is `Numeric`\r\n  * [`Pos`](http://www.rubydoc.info/gems/contracts/Contracts/Pos) – checks that the argument is a positive number\r\n  * [`Neg`](http://www.rubydoc.info/gems/contracts/Contracts/Neg) – checks that the argument is a negative number\r\n  * [`Nat`](http://www.rubydoc.info/gems/contracts/Contracts/Nat) – checks that the argument is a natural number (>= 0)\r\n  * [`Bool`](http://www.rubydoc.info/gems/contracts/Contracts/Bool) – checks that the argument is `true` or `false`\r\n  * [`Any`](http://www.rubydoc.info/gems/contracts/Contracts/Any) – Passes for any argument. Use when the argument has no constraints.\r\n  * [`None`](http://www.rubydoc.info/gems/contracts/Contracts/None) – Fails for any argument. Use when the method takes no arguments.\r\n\r\n* Logical combinations\r\n  * [`Maybe`](http://www.rubydoc.info/gems/contracts/Contracts/Maybe) – specifies that a value _may be_ nil, e.g. `Maybe[String]` (equivalent to `Or[String,nil]`)\r\n  * [`Or`](http://www.rubydoc.info/gems/contracts/Contracts/Or) – passes if any of the given contracts pass, e.g. `Or[Fixnum, Float]`\r\n  * [`Xor`](http://www.rubydoc.info/gems/contracts/Contracts/Xor) – passes if exactly one of the given contracts pass, e.g. `Xor[Fixnum, Float]`\r\n  * [`And`](http://www.rubydoc.info/gems/contracts/Contracts/And) – passes if all contracts pass, e.g. `And[Nat, -> (n) { n.even? }]`\r\n  * [`Not`](http://www.rubydoc.info/gems/contracts/Contracts/Not) – passes if all contracts fail for the given argument, e.g. `Not[nil]`\r\n\r\n* Collections\r\n  * [`ArrayOf`](http://www.rubydoc.info/gems/contracts/Contracts/ArrayOf) – checks that the argument is an array, and all elements pass the given contract, e.g. `ArrayOf[Num]`\r\n  * [`SetOf`](http://www.rubydoc.info/gems/contracts/Contracts/SetOf) – checks that the argument is a set, and all elements pass the given contract, e.g. `SetOf[Num]`\r\n  * [`HashOf`](http://www.rubydoc.info/gems/contracts/Contracts/HashOf) – checks that the argument is a hash, and all keys and values pass the given contract, e.g. `HashOf[Symbol => String]` or `HashOf[Symbol,String]`\r\n  * [`RangeOf`](http://www.rubydoc.info/gems/contracts/Contracts/RangeOf) – checks that the argument is a range whose elements (#first and #last) pass the given contract, e.g. `RangeOf[Date]`\r\n  * [`Enum`](http://www.rubydoc.info/gems/contracts/Contracts/Enum) – checks that the argument is part of a given collection of objects, e.g. `Enum[:a, :b, :c]`\r\n\r\n* Keyword arguments\r\n  * [`KeywordArgs`](http://www.rubydoc.info/gems/contracts/Contracts/KeywordArgs) – checks that the argument is an options hash, and all required keyword arguments are present, and all values pass their respective contracts, e.g. `KeywordArgs[:number => Num, :description => Optional[String]]`\r\n  * [`Optional`](http://www.rubydoc.info/gems/contracts/Contracts/Optional) – checks that the keyword argument is either not present or pass the given contract, can not be used outside of `KeywordArgs` contract, e.g. `Optional[Num]`\r\n\r\n* Duck typing\r\n  * [`RespondTo`](http://www.rubydoc.info/gems/contracts/Contracts/RespondTo) – checks that the argument responds to all of the given methods, e.g. `RespondTo[:password, :credit_card]`\r\n  * [`Send`](http://www.rubydoc.info/gems/contracts/Contracts/Send) – checks that all named methods return a truthy value, e.g. `Send[:valid?]`\r\n\r\n* Miscellaneous\r\n  * [`Exactly`](http://www.rubydoc.info/gems/contracts/Contracts/Exactly) – checks that the argument has the given type, not accepting sub-classes, e.g. `Exactly[Numeric]`.\r\n  * [`Eq`](http://www.rubydoc.info/gems/contracts/Contracts/Eq) – checks that the argument is precisely equal to the given value, e.g. `Eq[String]` matches the class `String` and not a string instance.\r\n  * [`Func`](http://www.rubydoc.info/gems/contracts/Contracts/Func) – specifies the contract for a proc/lambda e.g. `Contract ArrayOf[Num], Func[Num => Num] => ArrayOf[Num]`. See section \"Contracts On Functions\".\r\n\r\nTo see all the built-in contracts and their full descriptions, check out the [RDoc](http://rubydoc.info/gems/contracts/Contracts).\r\n\r\nIt is recommended to use shortcut for referring builtin contracts:\r\n\r\n```ruby\r\n# define shortcut somewhere at the top level of your codebase:\r\nC = Contracts\r\n\r\n# and use it:\r\nContract C::Maybe[C::Num], String => C::Num\r\n```\r\n\r\nShortcut name should not be necessary `C`, can be anything that you are comfort\r\nwith while typing and anything that does not conflict with libraries you use.\r\n\r\nAll examples after this point assume you have chosen a shortcut as `C::`.\r\n\r\nIf you are sure, that builtin contracts will not nameclash with your own code\r\nand libraries you may use, then you can include all builtin contracts in your\r\nclass/module:\r\n\r\n```ruby\r\nclass Example\r\n  include Contracts::Core\r\n  include Contracts::Builtin\r\n\r\n  Contract Maybe[Num], Or[Float, String] => Bool\r\n  def complicated_algorithm(a, b)\r\n    # ...\r\n  end\r\nend\r\n```\r\n\r\n## More Examples\r\n\r\n### Hello, World\r\n\r\n```ruby\r\nContract String => nil\r\ndef hello(name)\r\n  puts \"hello, #{name}!\"\r\nend\r\n```\r\n\r\nYou always need to specify a contract for the return value. In this example, `hello` doesn't return anything, so the contract is `nil`. Now you know that you can use a constant like `nil` as the end of a contract. Valid values for a contract are:\r\n\r\n- the name of a class (like `String` or `Fixnum`)\r\n- a constant (like `nil` or `1`)\r\n- a `Proc` that takes a value and returns true or false to indicate whether the contract passed or not\r\n- a class that responds to the `valid?` class method (more on this later)\r\n- an instance of a class that responds to the `valid?` method (more on this later)\r\n\r\n### A Double Function\r\n\r\n```ruby\r\nContract C::Or[Fixnum, Float] => C::Or[Fixnum, Float]\r\ndef double(x)\r\n  2 * x\r\nend\r\n```\r\n\r\nSometimes you want to be able to choose between a few contracts. `Or` takes a variable number of contracts and checks the argument against all of them. If it passes for any of the contracts, then the `Or` contract passes.\r\nThis introduces some new syntax. One of the valid values for a contract is an instance of a class that responds to the `valid?` method. This is what `Or[Fixnum, Float]` is. The longer way to write it would have been:\r\n\r\n```ruby\r\nContract C::Or.new(Fixnum, Float) => C::Or.new(Fixnum, Float)\r\n```\r\n\r\nAll the built-in contracts have overridden the square brackets (`[]`) to give the same functionality. So you could write\r\n\r\n```ruby\r\nContract C::Or[Fixnum, Float] => C::Or[Fixnum, Float]\r\n```\r\n\r\nor\r\n\r\n```ruby\r\nContract C::Or.new(Fixnum, Float) => C::Or.new(Fixnum, Float)\r\n```\r\n\r\nwhichever you prefer. They both mean the same thing here: make a new instance of `Or` with `Fixnum` and `Float`. Use that instance to validate the argument.\r\n\r\n### A Product Function\r\n\r\n```ruby\r\nContract C::ArrayOf[C::Num] => C::Num\r\ndef product(vals)\r\n  total = 1\r\n  vals.each do |val|\r\n    total *= val\r\n  end\r\n  total\r\nend\r\n```\r\n\r\nThis contract uses the `ArrayOf` contract. Here's how `ArrayOf` works: it takes a contract. It expects the argument to be a list. Then it checks every value in that list to see if it satisfies that contract.\r\n\r\n```ruby\r\n# passes\r\nproduct([1, 2, 3, 4])\r\n\r\n# fails\r\nproduct([1, 2, 3, \"foo\"])\r\n```\r\n\r\n### Another Product Function\r\n\r\n```ruby\r\nContract C::Args[C::Num] => C::Num\r\ndef product(*vals)\r\n  total = 1\r\n  vals.each do |val|\r\n    total *= val\r\n  end\r\n  total\r\nend\r\n```\r\n\r\nThis function uses varargs (`*args`) instead of an array. To make a contract on varargs, use the `Args` contract. It takes one contract as an argument and uses it to validate every element passed in through `*args`. So for example,\r\n\r\n`Args[Num]` means they should all be numbers.\r\n\r\n`Args[Or[Num, String]]` means they should all be numbers or strings.\r\n\r\n`Args[Any]` means all arguments are allowed (`Any` is a contract that passes for any argument).\r\n\r\n### Contracts On Arrays\r\n\r\nIf an array is one of the arguments and you know how many elements it's going to have, you can put a contract on it:\r\n\r\n```ruby\r\n# a function that takes an array of two elements...a person's age and a person's name.\r\nContract [C::Num, String] => nil\r\ndef person(data)\r\n  p data\r\nend\r\n```\r\n\r\nIf you don't know how many elements it's going to have, use `ArrayOf`.\r\n\r\n### Contracts On Hashes\r\n\r\nHere's a contract that requires a Hash. We can put contracts on each of the keys:\r\n\r\n```ruby\r\n# note the parentheses around the hash; without those you would get a syntax error\r\nContract ({ :age => C::Num, :name => String }) => nil\r\ndef person(data)\r\n  p data\r\nend\r\n```\r\n\r\nThen if someone tries to call the function with bad data, it will fail:\r\n\r\n```ruby\r\n# error: age can't be nil!\r\nperson({:name => \"Adit\", :age => nil})\r\n```\r\n\r\nYou don't need to put a contract on every key. So this call would succeed:\r\n\r\n```ruby\r\nperson({:name => \"Adit\", :age => 42, :foo => \"bar\"})\r\n```\r\n\r\neven though we don't specify a type for `:foo`.\r\n\r\nPeruse this contract on the keys and values of a Hash.\r\n\r\n```ruby\r\nContract C::HashOf[Symbol, C::Num] => C::Num\r\ndef give_largest_value(hsh)\r\n  hsh.values.max\r\nend\r\n```\r\nWhich you use like so:\r\n```ruby\r\n# succeeds\r\ngive_largest_value(a: 1, b: 2, c: 3) # returns 3\r\n\r\n# fails\r\ngive_largest_value(\"a\" => 1, 2 => 2, c: 3)\r\n```\r\n\r\n### Contracts On Strings\r\n\r\nWhen you want a contract to match not just any string (i.e. `Contract String => nil`), you can use regular expressions:\r\n```ruby\r\nContract /World|Mars/i => nil\r\ndef greet(name)\r\n  puts \"Hello #{name}!\"\r\nend\r\n```\r\n\r\nUsing logical combinations you can combine existing definitions, instead of writing 1 big regular expression:\r\n```ruby\r\nContract C::And[default_mail_regexp, /#{AppConfig.domain}\\z/] => nil\r\ndef send_admin_invite(email)\r\n```\r\n\r\n### Contracts On Keyword Arguments\r\n\r\nruby 2.0+, but can be used for normal hashes too, when keyword arguments are\r\nnot available\r\n\r\nLets say you are writing a simple function and require a bunch of keyword arguments:\r\n\r\n```ruby\r\ndef connect(host, port:, user:, password:)\r\n```\r\n\r\nYou can of course put `Hash` contract on it:\r\n\r\n```ruby\r\nContract String, { :port => C::Num, :user => String, :password => String } => Connection\r\ndef connect(host, port:, user:, password:)\r\n```\r\n\r\nBut this will not quite work if you want to have a default values:\r\n\r\n```ruby\r\nContract String, { :port => C::Num, :user => String, :password => String } => Connection\r\ndef connect(host, port: 5000, user:, password:)\r\n  # ...\r\nend\r\n\r\n# No value is passed for port\r\nconnect(\"example.org\", user: \"me\", password: \"none\")\r\n```\r\n\r\nResults in:\r\n\r\n```\r\nContractError: Contract violation for argument 2 of 2:\r\n        Expected: {:port=>Num, :user=>String, :password=>String},\r\n        Actual: {:user=>\"me\", :password=>\"none\"}\r\n        Value guarded in: Object::connect\r\n        With Contract: String, Hash => Connection\r\n        At: (irb):12\r\n```\r\n\r\nThis can be fixed with contract `{ :port => C::Maybe[C::Num], ... }`, but that will\r\nallow `nil` to be passed in, which is not the original intent.\r\n\r\nSo that is where `KeywordArgs` and `Optional` contracts jump in:\r\n\r\n```ruby\r\nContract String, C::KeywordArgs[ :port => C::Optional[C::Num], :user => String, :password => String ] => Connection\r\ndef connect(host, port: 5000, user:, password:)\r\n```\r\n\r\nIt looks just like the hash contract, but wrapped in `KeywordArgs` contract. Notice the usage of `Optional` contract - this way you specify that `:port` argument is optional. And it will not fail, when you omit this argument, but it will fail when you pass in `nil`.\r\n\r\n### Contracts On Functions\r\n\r\nLets say you are writing a simple map function:\r\n\r\n```ruby\r\ndef map(arr, func)\r\n```\r\n\r\n`map` takes an array, and a function. Suppose you want to add a contract to this function. You could try this:\r\n\r\n```ruby\r\nContract C::ArrayOf[C::Any], Proc => C::ArrayOf[C::Any]\r\ndef map(arr, func)\r\n```\r\n\r\nThis says that the second argument should be a `Proc`. You can call the function like so:\r\n\r\n```ruby\r\np map([1, 2, 3], lambda { |x| x + 1 }) # works\r\n```\r\n\r\nBut suppose you want to have a contract on the Proc too! Suppose you want to make sure that the Proc returns a number. Use the `Func` contract. `Func` takes a contract as its argument, and uses that contract on the function that you pass in.\r\n\r\nHere's a `map` function that requires an array of numbers, and a function that takes a number and returns a number:\r\n\r\n```ruby\r\nContract C::ArrayOf[C::Num], C::Func[C::Num => C::Num] => C::ArrayOf[C::Num]\r\ndef map(arr, func)\r\n  ret = []\r\n  arr.each do |x|\r\n    ret << func[x]\r\n  end\r\n  ret\r\nend\r\n```\r\n\r\nEarlier, we used `Proc`, which just says \"make sure the second variable is a Proc\". Now we are using `Func[Num => Num]`, which says \"make sure the second variable is a Proc that takes a number and returns a number\". Better!\r\n\r\nTry this map function with these two examples:\r\n\r\n```ruby\r\np map([1, 2, 3], lambda { |x| x + 1 }) # works\r\np map([1, 2, 3], lambda { |x| \"oops\" }) # fails, the lambda returns a string.\r\n```\r\n\r\nThe above examples showed a method accepting a `Proc` as the last argument, but the same contract works on methods that accept a block:\r\n\r\n```ruby\r\ndef map(arr, &block)\r\n```\r\n\r\nNOTE: This is not valid:\r\n\r\n```ruby\r\nContract C::ArrayOf[C::Num], C::Func => C::ArrayOf[C::Num]\r\ndef map(arr, &func)\r\n```\r\n\r\nHere I am using `Func` without specifying a contract, like `Func[Num => Num]`. That's not a legal contract. If you just want to validate that the second argument is a proc, use `Proc`.\r\n\r\n### Returning Multiple Values\r\nTreat the return value as an array. For example, here's a function that returns two numbers:\r\n\r\n```ruby\r\nContract C::Num => [C::Num, C::Num]\r\ndef mult(x)\r\n  return x, x+1\r\nend\r\n```\r\n\r\n## Synonyms For Contracts\r\n\r\nIf you use a contract a lot, it's a good idea to give it a meaningful synonym that tells the reader more about what your code returns. For example, suppose you have many functions that return a `Hash` or `nil`. If a `Hash` is returned, it contains information about a person. Your contact might look like this:\r\n\r\n```ruby\r\nContract String => C::Or[Hash, nil]\r\ndef some_func(str)\r\n```\r\n\r\nYou can make your contract more meaningful with a synonym:\r\n\r\n```ruby\r\n# the synonym\r\nPerson = Or[Hash, nil]\r\n\r\n# use the synonym here\r\nContract String => Person\r\ndef some_func(str)\r\n```\r\n\r\nNow you can use `Person` wherever you would have used `Or[Hash, nil]`. Your code is now cleaner and more clearly says what the function is doing.\r\n\r\n## Defining Your Own Contracts\r\n\r\nContracts are very easy to define. To re-iterate, there are 5 kinds of contracts:\r\n\r\n- the name of a class (like `String` or `Fixnum`)\r\n- a constant (like `nil` or `1`)\r\n- a `Proc` that takes a value and returns true or false to indicate whether the contract passed or not\r\n- a class that responds to the `valid?` class method (more on this later)\r\n- an instance of a class that responds to the `valid?` method (more on this later)\r\n\r\nThe first two don't need any extra work to define: you can just use any constant or class name in your contract and it should just work. Here are examples for the rest:\r\n\r\n### A Proc\r\n\r\n```ruby\r\nContract lambda { |x| x.is_a? Numeric } => C::Num\r\ndef double(x)\r\n```\r\n\r\nThe lambda takes one parameter: the argument that is getting passed to the function. It checks to see if it's a `Numeric`. If it is, it returns true. Otherwise it returns false.\r\nIt's not good practice to write a lambda right in your contract...if you find yourself doing it often, write it as a class instead:\r\n\r\n### A Class With `valid?` As a Class Method\r\n\r\nHere's how the `Num` class is defined. It does exactly what the `lambda` did in the previous example:\r\n\r\n```ruby\r\nclass Num\r\n  def self.valid? val\r\n    val.is_a? Numeric\r\n  end\r\nend\r\n```\r\n\r\nThe `valid?` class method takes one parameter: the argument that is getting passed to the function. It returns true or false.\r\n\r\n### A Class With `valid?` As an Instance Method\r\n\r\nHere's how the `Or` class is defined:\r\n\r\n```ruby\r\nclass Or < CallableClass\r\n  def initialize(*vals)\r\n    @vals = vals\r\n  end\r\n\r\n  def valid?(val)\r\n    @vals.any? do |contract|\r\n      res, _ = Contract.valid?(val, contract)\r\n      res\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe `Or` contract takes a sequence of contracts, and passes if any of them pass. It uses `Contract.valid?` to validate the value against the contracts.\r\n\r\nThis class inherits from `CallableClass`, which allows us to use `[]` when using the class:\r\n\r\n```ruby\r\nContract C::Or[Fixnum, Float] => C::Num\r\ndef double(x)\r\n  2 * x\r\nend\r\n```\r\n\r\nWithout `CallableClass`, we would have to use `.new` instead:\r\n\r\n```ruby\r\nContract C::Or.new(Fixnum, Float) => C::Num\r\ndef double(x)\r\n# etc\r\n```\r\n\r\nYou can use `CallableClass` in your own contracts to make them callable using `[]`.\r\n\r\n## Customizing Error Messages\r\n\r\nWhen a contract fails, part of the error message prints the contract:\r\n\r\n    ...\r\n    Expected: Contracts::Num,\r\n    ...\r\n\r\nYou can customize this message by overriding the `to_s` method on your class or proc. For example, suppose we overrode `Num`'s `to_s` method:\r\n\r\n```ruby\r\ndef Num.to_s\r\n  \"a number please\"\r\nend\r\n```\r\n\r\nNow the error says:\r\n\r\n    ...\r\n    Expected: a number please,\r\n    ...\r\n\r\n## Failure Callbacks\r\n\r\nSupposing you don't want contract failures to become exceptions. You run a popular website, and when there's a contract exception you would rather log it and continue than throw an exception and break your site.\r\n\r\ncontracts.ruby provides a failure callback that gets called when a contract fails. For example, here we log every failure instead of raising an error:\r\n\r\n```ruby\r\nContract.override_failure_callback do |data|\r\n  puts \"You had an error\"\r\n  puts failure_msg(data)\r\nend\r\n```\r\n\r\n`failure_msg` is a function that prints out information about the failure. Your failure callback gets a hash with the following values:\r\n\r\n    {\r\n      :arg => the argument to the method,\r\n      :contract => the contract that got violated,\r\n      :class => the method's class,\r\n      :method => the method,\r\n      :contracts => the contract object\r\n    }\r\n\r\nIf your failure callback returns `false`, the method that the contract is guarding will not be called (the default behaviour).\r\n\r\n## Providing your own custom validators\r\n\r\nThis can be done with `Contract.override_validator`:\r\n\r\n```ruby\r\n# Make contracts accept all RSpec doubles\r\nContract.override_validator(:class) do |contract|\r\n  lambda do |arg|\r\n    arg.is_a?(RSpec::Mocks::Double) ||\r\n      arg.is_a?(contract)\r\n  end\r\nend\r\n```\r\n\r\nThe block you provide should always return lambda accepting one argument - validated argument. Block itself accepts contract as an argument.\r\n\r\nPossible validator overrides:\r\n\r\n- `override_validator(MyCustomContract)` - allows to add some special behaviour for custom contracts,\r\n- `override_validator(Proc)` - e.g. `lambda { true }`,\r\n- `override_validator(Array)` - e.g. `[C::Num, String]`,\r\n- `override_validator(Hash)` - e.g. `{ :a => C::Num, :b => String }`,\r\n- `override_validator(Range)` - e.g. `(1..10)`,\r\n- `override_validator(Regexp)` - e.g. `/foo/`,\r\n- `override_validator(Contracts::Args)` - e.g. `C::Args[C::Num]`,\r\n- `override_validator(Contracts::Func)` - e.g. `C::Func[C::Num => C::Num]`,\r\n- `override_validator(:valid)` - allows to override how contracts that respond to `:valid?` are handled,\r\n- `override_validator(:class)` - allows to override how class/module contract constants are handled,\r\n- `override_validator(:default)` - otherwise, raw value contracts.\r\n\r\nDefault validators can be found here: [lib/contracts/validators.rb](https://github.com/egonSchiele/contracts.ruby/blob/master/lib/contracts/validators.rb).\r\n\r\n## Disabling contracts\r\n\r\nIf you want to disable contracts, set the `NO_CONTRACTS` environment variable. This will disable contracts and you won't have a performance hit. Pattern matching will still work if you disable contracts in this way! With NO_CONTRACTS only pattern-matching contracts are defined.\r\n\r\n## Method overloading\r\n\r\nYou can use contracts for method overloading! This is commonly called \"pattern matching\" in functional programming languages.\r\n\r\nFor example, here's a factorial function without method overloading:\r\n\r\n```ruby\r\nContract C::Num => C::Num\r\ndef fact x\r\n  if x == 1\r\n    x\r\n  else\r\n    x * fact(x - 1)\r\n  end\r\nend\r\n```\r\n\r\nHere it is again, re-written with method overloading:\r\n\r\n```ruby\r\nContract 1 => 1\r\ndef fact x\r\n  x\r\nend\r\n\r\nContract C::Num => C::Num\r\ndef fact x\r\n  x * fact(x - 1)\r\nend\r\n```\r\n\r\nFor an argument, each function will be tried in order. The first function that doesn't raise a `ContractError` will be used. So in this case, if x == 1, the first function will be used. For all other values, the second function will be used.\r\n\r\nThis allows you write methods more declaratively, rather than using conditional branching. This feature is not only useful for recursion; you can use it to keep parallel use cases separate:\r\n\r\n```ruby\r\nContract lambda{|n| n < 12 } => Ticket\r\ndef get_ticket(age)\r\n  ChildTicket.new(age: age)\r\nend\r\n\r\nContract lambda{|n| n >= 12 } => Ticket\r\ndef get_ticket(age)\r\n  AdultTicket.new(age: age)\r\nend\r\n\r\n```\r\n\r\nNote that the second `get_ticket` contract above could have been simplified to:\r\n\r\n```ruby\r\nContract C::Num => Ticket\r\n```\r\n\r\nThis is because the first contract eliminated the possibility of `age` being less than 12. However, the simpler contract is less explicit; you may want to \"spell out\" the age condition for clarity, especially if the method is overloaded with many contracts.\r\n\r\n## Contracts in modules\r\n\r\nUsage is the same as contracts in classes:\r\n\r\n```ruby\r\nmodule M\r\n  include Contracts::Core\r\n\r\n  Contract String => String\r\n  def self.parse\r\n    # do some hard parsing\r\n  end\r\nend\r\n```\r\n\r\n## Invariants\r\n\r\nInvariants are conditions on objects that should always hold. If after any method call on given object, any of the Invariants fails, then Invariant violation error will be generated.\r\n\r\n**NOTE**: Only methods with contracts will be affected.\r\n\r\nA simple example:\r\n\r\n```ruby\r\nclass MyBirthday < Struct.new(:day, :month)\r\n  include Contracts::Core\r\n  include Contracts::Invariants\r\n\r\n  invariant(:day) { 1 <= day && day <= 31 }\r\n  invariant(:month) { 1 <= month && month <= 12 }\r\n\r\n  Contract C::None => Fixnum\r\n  def silly_next_day!\r\n    self.day += 1\r\n  end\r\nend\r\n\r\nbirthday = MyBirthday.new(31, 12)\r\nbirthday.silly_next_day!\r\n```\r\n\r\nIf you run it, last line will generate invariant violation:\r\n\r\n```ruby\r\n./invariant.rb:38:in `failure_callback': Invariant violation: (RuntimeError)\r\n   Expected: day condition to be true\r\n   Actual: false\r\n   Value guarded in: MyBirthday::silly_next_day!\r\n   At: main.rb:9\r\n```\r\n\r\nWhich means, that after `#silly_next_day!` all checks specified in `invariant` statement will be verified, and if at least one fail, then invariant violation error will be raised.\r\n\r\n## Using contracts within your own code\r\n\r\ncontracts.ruby is obviously designed to check method parameters and return values. But if you want to check whether some other data obeys a contract, you can use `Contract.valid?(value, contract)`. For instance:\r\n\r\n```ruby\r\ndata = parse(user_input)\r\nunless Contract.valid?(data, HashOf[String,Nat])\r\n  raise UserInputError.new(user_input)\r\nend\r\n```\r\n\r\n## Auto-generate documentation using contracts\r\n\r\nIf you are generating documentation for your code with [YARD](http://yardoc.org/), check out [yard-contracts](https://github.com/sfcgeorge/yard-contracts). It will automatically annotate your functions with contracts information. Instead of documenting each parameter for a function yourself, you can just add a contract and yard-contracts will generate the documentation for you!\r\n\r\n## Misc\r\n\r\nPlease submit any bugs [here](https://github.com/egonSchiele/contracts.ruby/issues) and I'll try to get them resolved ASAP!\r\n\r\nSee any mistakes in this tutorial? I try to make it bug-free, but they can creep in. [File an issue](https://github.com/egonSchiele/contracts.ruby/issues).\r\n\r\nIf you're using the library, please [let me know](https://github.com/egonSchiele) what project you're using it on :)\r\n\r\nSee the [wiki](https://github.com/egonSchiele/contracts.ruby/wiki) for more info.\r\n\r\nHappy Coding!","google":"UA-32498338-1","note":"Don't delete this file! It's used internally to help with page regeneration."}