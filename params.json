{"name":"Contracts.ruby","tagline":"Contracts for Ruby","body":"# The contracts.ruby tutorial\r\n\r\n## Introduction\r\n\r\ncontracts.ruby brings code contracts to the Ruby language. Code contracts allow you make some assertions about your code, and then checks them to make sure they hold. This lets you\r\n\r\n- catch bugs faster\r\n- make it very easy to catch certain types of bugs\r\n- make sure that the user gets proper messaging when a bug occurs.\r\n\r\n## Installation\r\n\r\n    gem install contracts\r\n\r\n## Basics\r\n\r\nA simple example:\r\n\r\n```ruby\r\nContract Num, Num => Num\r\ndef add(a, b)\r\n  a + b\r\nend\r\n```\r\n\r\nHere, the contract is `Contract Num, Num => Num`. This says that the `add` function takes two numbers and returns a number.\r\n\r\nCopy this code into a file and run it:\r\n\r\n```ruby\r\nrequire 'contracts'\r\n\r\nclass Math\r\n  include Contracts\r\n\r\n  Contract Num, Num => Num\r\n  def self.add(a, b)\r\n    a + b\r\n  end\r\nend\r\n\r\nputs Math.add(1, \"foo\")\r\n```\r\n\r\nYou'll see a detailed error message like so:\r\n\r\n    ./contracts.rb:60:in `failure_callback': Contract violation: (RuntimeError)\r\n        Expected: Contracts::Num,\r\n        Actual: \"foo\"\r\n        Value guarded in: Object::add\r\n        With Contract: Contracts::Num, Contracts::Num\r\n        At: foo.rb:6\r\n\r\nThat tells you that your contract was violated! `add` expected a `Num`, and got a string (`\"foo\"`) instead.\r\nBy default, an exception is thrown when a contract fails. This can be changed to do whatever you want. More on this later.\r\n\r\nYou can also see the contract for a function with the `functype` method:\r\n\r\n    functype(:add)\r\n    => \"add :: Num, Num => Num\"\r\n\r\nThis can be useful if you're in a REPL and want to figure out how a function should be used.\r\n\r\n## Built-in Contracts\r\n\r\n`Num` is one of the built-in contracts that contracts.ruby comes with. The built-in contracts are in the `Contracts` namespace. The easiest way to use them is to include the `Contracts` module in your class/module.\r\n\r\ncontracts.ruby comes with a lot of built-in contracts, including the following:\r\n\r\n* [`Num`](http://www.rubydoc.info/gems/contracts/Contracts/Num) – checks that the argument is `Numeric`\r\n* [`Pos`](http://www.rubydoc.info/gems/contracts/Contracts/Pos) – checks that the argument is a positive number\r\n* [`Neg`](http://www.rubydoc.info/gems/contracts/Contracts/Neg) – checks that the argument is a negative number\r\n* [`Nat`](http://www.rubydoc.info/gems/contracts/Contracts/Nat) – checks that the argument is a natural number\r\n* [`Bool`](http://www.rubydoc.info/gems/contracts/Contracts/Bool) – checks that the argument is `true` or `false`\r\n* [`Any`](http://www.rubydoc.info/gems/contracts/Contracts/Any) – Passes for any argument. Use when the argument has no constraints.\r\n* [`None`](http://www.rubydoc.info/gems/contracts/Contracts/None) – Fails for any argument. Use when the method takes no arguments.\r\n* [`Or`](http://www.rubydoc.info/gems/contracts/Contracts/Or) – passes if any of the given contracts pass, e.g. `Or[Fixnum, Float]`\r\n* [`Xor`](http://www.rubydoc.info/gems/contracts/Contracts/Xor) – passes if exactly one of the given contracts pass, e.g. `Xor[Fixnum, Float]`\r\n* [`And`](http://www.rubydoc.info/gems/contracts/Contracts/And) – passes if all contracts pass, e.g. `And[Fixnum, Float]`\r\n* [`Not`](http://www.rubydoc.info/gems/contracts/Contracts/Not) – passes if all contracts fail for the given argument, e.g. `Not[nil]`\r\n* [`ArrayOf`](http://www.rubydoc.info/gems/contracts/Contracts/ArrayOf) – checks that the argument is an array, and all elements pass the given contract, e.g. `ArrayOf[Num]`\r\n* [`HashOf`](http://www.rubydoc.info/gems/contracts/Contracts/HashOf) – checks that the argument is a hash, and all keys and values pass the given contract, e.g. `HashOf[Symbol, String]`\r\n* [`Maybe`](http://www.rubydoc.info/gems/contracts/Contracts/Maybe) – passes if the argument is `nil`, or if the given contract passes\r\n* [`RespondTo`](http://www.rubydoc.info/gems/contracts/Contracts/RespondTo) – checks that the argument responds to all of the given methods, e.g. `RespondTo[:password, :credit_card]`\r\n* [`Send`](http://www.rubydoc.info/gems/contracts/Contracts/Send) – checks that all named methods return true, e.g. `Send[:valid?]`\r\n* [`Exactly`](http://www.rubydoc.info/gems/contracts/Contracts/Exactly) – checks that the argument has the given type, not accepting sub-classes, e.g. `Exactly[Numeric]`.\r\n\r\nTo see all the built-in contracts and their full descriptions, check out the [RDoc](http://rubydoc.info/gems/contracts/Contracts).\r\n\r\n## More Examples\r\n\r\n### Hello, World\r\n\r\n```ruby\r\nContract String => nil\r\ndef hello(name)\r\n  puts \"hello, #{name}!\"\r\nend\r\n```\r\n\r\nYou always need to specify a contract for the return value. In this example, `hello` doesn't return anything, so the contract is `nil`. Now you know that you can use a constant like `nil` as the end of a contract. Valid values for a contract are:\r\n\r\n- the name of a class (like `String` or `Fixnum`)\r\n- a constant (like `nil` or `1`)\r\n- a `Proc` that takes a value and returns true or false to indicate whether the contract passed or not\r\n- a class that responds to the `valid?` class method (more on this later)\r\n- an instance of a class that responds to the `valid?` method (more on this later)\r\n\r\n### A Double Function\r\n\r\n```ruby\r\nContract Or[Fixnum, Float] => Or[Fixnum, Float]\r\ndef double(x)\r\n  2 * x\r\nend\r\n```\r\n\r\nSometimes you want to be able to choose between a few contracts. `Or` takes a variable number of contracts and checks the argument against all of them. If it passes for any of the contracts, then the `Or` contract passes.\r\nThis introduces some new syntax. One of the valid values for a contract is an instance of a class that responds to the `valid?` method. This is what `Or[Fixnum, Float]` is. The longer way to write it would have been:\r\n\r\n```ruby\r\nContract Or.new(Fixnum, Float) => Or.new(Fixnum, Float)\r\n```\r\n\r\nAll the built-in contracts have overridden the square brackets (`[]`) to give the same functionality. So you could write\r\n\r\n```ruby\r\nContract Or[Fixnum, Float] => Or[Fixnum, Float]\r\n```\r\n\r\nor\r\n\r\n```ruby\r\nContract Or.new(Fixnum, Float) => Or.new(Fixnum, Float)\r\n```\r\n\r\nwhichever you prefer. They both mean the same thing here: make a new instance of `Or` with `Fixnum` and `Float`. Use that instance to validate the argument.\r\n\r\n### A Product Function\r\n\r\n```ruby\r\nContract ArrayOf[Num] => Num\r\ndef product(vals)\r\n  total = 1\r\n  vals.each do |val|\r\n    total *= val\r\n  end\r\n  total\r\nend\r\n```\r\n\r\nThis contract uses the `ArrayOf` contract. Here's how `ArrayOf` works: it takes a contract. It expects the argument to be a list. Then it checks every value in that list to see if it satisfies that contract.\r\n\r\n```ruby\r\n# passes\r\nproduct([1, 2, 3, 4])\r\n\r\n# fails\r\nproduct([1, 2, 3, \"foo\"])\r\n```\r\n\r\n### Another Product Function\r\n\r\n```ruby\r\nContract Args[Num] => Num\r\ndef product(*vals)\r\n  total = 1\r\n  vals.each do |val|\r\n    total *= val\r\n  end\r\n  total\r\nend\r\n```\r\n\r\nThis function uses varargs (`*args`) instead of an array. To make a contract on varargs, use the `Args` contract. It takes one contract as an argument and uses it to validate every element passed in through `*args`. So for example,\r\n\r\n`Args[Num]` means they should all be numbers.\r\n\r\n`Args[Or[Num, String]]` means they should all be numbers or strings.\r\n\r\n`Args[Any]` means all arguments are allowed (`Any` is a contract that passes for any argument).\r\n\r\n### Contracts On Arrays\r\n\r\nIf an array is one of the arguments and you know how many elements it's going to have, you can put a contract on it:\r\n\r\n```ruby\r\n# a function that takes an array of two elements...a person's age and a person's name.\r\nContract [Num, String] => nil\r\ndef person(data)\r\n  p data\r\nend\r\n```\r\n\r\nIf you don't know how many elements it's going to have, use `ArrayOf`.\r\n\r\n### Contracts On Hashes\r\n\r\nHere's a contract that requires a Hash. We can put contracts on each of the keys:\r\n\r\n```ruby\r\n# note the parentheses around the hash; without those you would get a syntax error\r\nContract ({ :age => Num, :name => String }) => nil\r\ndef person(data)\r\n  p data\r\nend\r\n```\r\n\r\nThen if someone tries to call the function with bad data, it will fail:\r\n\r\n```ruby\r\n# error: age can't be nil!\r\nperson({:name => \"Adit\", :age => nil})\r\n```\r\n\r\nYou don't need to put a contract on every key. So this call would succeed:\r\n\r\n```ruby\r\nperson({:name => \"Adit\", :age => 42, :foo => \"bar\"})\r\n```\r\n\r\neven though we don't specify a type for `:foo`.\r\n\r\nPeruse this contract on the keys and values of a Hash.\r\n\r\n```ruby\r\nContract HashOf[Symbol, Num] => Num\r\ndef give_largest_value(hsh)\r\n  hsh.values.max\r\nend\r\n```\r\nWhich you use like so:\r\n```ruby\r\n# succeeds\r\ngive_largest_value(a: 1, b: 2, c: 3) # returns 3\r\n\r\n# fails\r\ngive_largest_value(\"a\" => 1, 2 => 2, c: 3)\r\n```\r\n\r\n### Contracts On Functions\r\n\r\nLets say you are writing a simple map function:\r\n\r\n```ruby\r\ndef map(arr, func)\r\n```\r\n\r\n`map` takes an array, and a function. Suppose you want to add a contract to this function. You could try this:\r\n\r\n```ruby\r\nContract ArrayOf[Any], Proc => ArrayOf[Any]\r\ndef map(arr, func)\r\n```\r\n\r\nThis says that the second argument should be a `Proc`. You can call the function like so:\r\n\r\n```ruby\r\np map([1, 2, 3], lambda { |x| x + 1 }) # works\r\n```\r\n\r\nBut suppose you want to have a contract on the Proc too! Suppose you want to make sure that the Proc returns a number. Use the `Func` contract. `Func` takes a contract as it's argument, and uses that contract on the function that you pass in.\r\n\r\nHere's a `map` function that requires an array of numbers, and a function that takes a number and returns a number:\r\n\r\n```ruby\r\nContract ArrayOf[Num], Func[Num => Num] => ArrayOf[Num]\r\ndef map(arr, func)\r\n  ret = []\r\n  arr.each do |x|\r\n    ret << func[x]\r\n  end\r\n  ret\r\nend\r\n```\r\n\r\nEarlier, we used `Proc`, which just says \"make sure the second variable is a Proc\". Now we are using `Func[Num => Num]`, which says \"make sure the second variable is a Proc that takes a number and returns a number\". Better!\r\n\r\nTry this map function with these two examples:\r\n\r\n```ruby\r\np map([1, 2, 3], lambda { |x| x + 1 }) # works\r\np map([1, 2, 3], lambda { |x| \"oops\" }) # fails, the lambda returns a string.\r\n```\r\n\r\nNOTE: This is not valid:\r\n\r\n```ruby\r\nContract ArrayOf[Num], Func => ArrayOf[Num]\r\ndef map(arr, &func)\r\n```\r\n\r\nHere I am using `Func` without specifying a contract, like `Func[Num => Num]`. That's not a legal contract. If you just want to validate that the second argument is a proc, use `Proc`.\r\n\r\n### Returning Multiple Values\r\nTreat the return value as an array. For example, here's a function that returns two numbers:\r\n\r\n```ruby\r\nContract Num => [Num, Num]\r\ndef mult(x)\r\n  return x, x+1\r\nend\r\n```\r\n\r\n## Synonyms For Contracts\r\n\r\nIf you use a contract a lot, it's a good idea to give it a meaningful synonym that tells the reader more about what your code returns. For example, suppose you have many functions that return a `Hash` or `nil`. If a `Hash` is returned, it contains information about a person. Your contact might look like this:\r\n\r\n```ruby\r\nContract String => Or[Hash, nil]\r\ndef some_func(str)\r\n```\r\n\r\nYou can make your contract more meaningful with a synonym:\r\n\r\n```ruby\r\n# the synonym\r\nPerson = Or[Hash, nil]\r\n\r\n# use the synonym here\r\nContract String => Person\r\ndef some_func(str)\r\n```\r\n\r\nNow you can use `Person` wherever you would have used `Or[Hash, nil]`. Your code is now cleaner and more clearly says what the function is doing.\r\n\r\n## Defining Your Own Contracts\r\n\r\nContracts are very easy to define. To re-iterate, there are 5 kinds of contracts:\r\n\r\n- the name of a class (like `String` or `Fixnum`)\r\n- a constant (like `nil` or `1`)\r\n- a `Proc` that takes a value and returns true or false to indicate whether the contract passed or not\r\n- a class that responds to the `valid?` class method (more on this later)\r\n- an instance of a class that responds to the `valid?` method (more on this later)\r\n\r\nThe first two don't need any extra work to define: you can just use any constant or class name in your contract and it should just work. Here are examples for the rest:\r\n\r\n### A Proc\r\n\r\n```ruby\r\nContract lambda { |x| x.is_a? Numeric } => Num\r\ndef double(x)\r\n```\r\n\r\nThe lambda takes one parameter: the argument that is getting passed to the function. It checks to see if it's a `Numeric`. If it is, it returns true. Otherwise it returns false.\r\nIt's not good practice to write a lambda right in your contract...if you find yourself doing it often, write it as a class instead:\r\n\r\n### A Class With `valid?` As a Class Method\r\n\r\nHere's how the `Num` class is defined. It does exactly what the `lambda` did in the previous example:\r\n\r\n```ruby\r\nclass Num\r\n  def self.valid? val\r\n    val.is_a? Numeric\r\n  end\r\nend\r\n```\r\n\r\nThe `valid?` class method takes one parameter: the argument that is getting passed to the function. It returns true or false.\r\n\r\n### A Class With `valid?` As an Instance Method\r\n\r\nHere's how the `Or` class is defined:\r\n\r\n```ruby\r\nclass Or < CallableClass\r\n  def initialize(*vals)\r\n    @vals = vals\r\n  end\r\n\r\n  def valid?(val)\r\n    @vals.any? do |contract|\r\n      res, _ = Contract.valid?(val, contract)\r\n      res\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe `Or` contract takes a sequence of contracts, and passes if any of them pass. It uses `Contract.valid?` to validate the value against the contracts.\r\n\r\nThis class inherits from `CallableClass`, which allows us to use `[]` when using the class:\r\n\r\n```ruby\r\nContract Or[Fixnum, Float] => Num\r\ndef double(x)\r\n  2 * x\r\nend\r\n```\r\n\r\nWithout `CallableClass`, we would have to use `.new` instead:\r\n\r\n```ruby\r\nContract Or.new(Fixnum, Float) => Num\r\ndef double(x)\r\n# etc\r\n```\r\n\r\nYou can use `CallableClass` in your own contracts to make them callable using `[]`.\r\n\r\n## Customizing Error Messages\r\n\r\nWhen a contract fails, part of the error message prints the contract:\r\n\r\n    ...\r\n    Expected: Contracts::Num,\r\n    ...\r\n\r\nYou can customize this message by overriding the `to_s` method on your class or proc. For example, suppose we overrode `Num`'s `to_s` method:\r\n\r\n```ruby\r\ndef Num.to_s\r\n  \"a number please\"\r\nend\r\n```\r\n\r\nNow the error says:\r\n\r\n    ...\r\n    Expected: a number please,\r\n    ...\r\n\r\n## Failure Callbacks\r\n\r\nSupposing you don't want contract failures to become exceptions. You run a popular website, and when there's a contract exception you would rather log it and continue than throw an exception and break your site.\r\n\r\ncontracts.ruby provides a failure callback that gets called when a contract fails. For example, here we log every failure instead of raising an error:\r\n\r\n```ruby\r\nContract.override_failure_callback do |data|\r\n  puts \"You had an error\"\r\n  puts failure_msg(data)\r\nend\r\n```\r\n\r\n`failure_msg` is a function that prints out information about the failure. Your failure callback gets a hash with the following values:\r\n\r\n    {\r\n      :arg => the argument to the method,\r\n      :contract => the contract that got violated,\r\n      :class => the method's class,\r\n      :method => the method,\r\n      :contracts => the contract object\r\n    }\r\n\r\nIf your failure callback returns `false`, the method that the contract is guarding will not be called (the default behaviour).\r\n\r\n## Disabling contracts\r\n\r\nIf you want to disable contracts, set the `NO_CONTRACTS` environment variable. This will disable contracts and you won't have a performance hit. Pattern matching will still work if you disable contracts in this way! With NO_CONTRACTS only pattern-matching contracts are defined.\r\n\r\n## Method overloading\r\n\r\nYou can use contracts for method overloading! This is commonly called \"pattern matching\" in functional programming languages.\r\n\r\nFor example, here's a factorial function without method overloading:\r\n\r\n```ruby\r\nContract Num => Num\r\ndef fact x\r\n  if x == 1\r\n    x\r\n  else\r\n    x * fact(x - 1)\r\n  end\r\nend\r\n```\r\n\r\nHere it is again, re-written with method overloading:\r\n\r\n```ruby\r\nContract 1 => 1\r\ndef fact x\r\n  x\r\nend\r\n\r\nContract Num => Num\r\ndef fact x\r\n  x * fact(x - 1)\r\nend\r\n```\r\n\r\nFor an argument, each function will be tried in order. The first function that doesn't raise a `ContractError` will be used. So in this case, if x == 1, the first function will be used. For all other values, the second function will be used.\r\n\r\nThis allows you write methods more declaratively, rather than using conditional branching. This feature is not only useful for recursion; you can use it to keep parallel use cases separate:\r\n\r\n```ruby\r\nContract lambda{|n| n < 12 } => Ticket\r\ndef get_ticket(age)\r\n  ChildTicket.new(age: age)\r\nend\r\n\r\nContract lambda{|n| n >= 12 } => Ticket\r\ndef get_ticket(age)\r\n  AdultTicket.new(age: age)\r\nend\r\n\r\n```\r\n\r\nNote that the second `get_ticket` contract above could have been simplified to:\r\n\r\n```ruby\r\nContract Num => Ticket\r\n```\r\n\r\nThis is because the first contract eliminated the possibility of `age` being less than 12. However, the simpler contract is less explicit; you may want to \"spell out\" the age condition for clarity, especially if the method is overloaded with many contracts.\r\n\r\n## Contracts in modules\r\n\r\nTo use contracts on module you need to include both `Contracts` and `Contracts::Modules` into it:\r\n\r\n```ruby\r\nmodule M\r\n  include Contracts\r\n  include Contracts::Modules\r\n\r\n  Contract String => String\r\n  def self.parse\r\n    # do some hard parsing\r\n  end\r\nend\r\n```\r\n\r\n## Invariants\r\n\r\nInvariants are conditions on objects that should always hold. If after any method call on given object, any of the Invariants fails, then Invariant violation error will be generated.\r\n\r\n**NOTE**: Only methods with contracts will be affected.\r\n\r\nA simple example:\r\n\r\n```ruby\r\nclass MyBirthday < Struct.new(:day, :month)\r\n  include Contracts\r\n  include Contracts::Invariants\r\n\r\n  invariant(:day) { 1 <= day && day <= 31 }\r\n  invariant(:month) { 1 <= month && month <= 12 }\r\n\r\n  Contract None => Fixnum\r\n  def silly_next_day!\r\n    self.day += 1\r\n  end\r\nend\r\n\r\nbirthday = MyBirthday.new(31, 12)\r\nbirthday.silly_next_day!\r\n```\r\n\r\nIf you run it, last line will generate invariant violation:\r\n\r\n```ruby\r\n./invariant.rb:38:in `failure_callback': Invariant violation: (RuntimeError)\r\n   Expected: day condition to be true\r\n   Actual: false\r\n   Value guarded in: MyBirthday::silly_next_day!\r\n   At: main.rb:9\r\n```\r\n\r\nWhich means, that after `#silly_next_day!` all checks specified in `invariant` statement will be verified, and if at least one fail, then invariant violation error will be raised.\r\n\r\n## Auto-generate documentation using contracts\r\n\r\nIf you are generating documentation for your code with [YARD](http://yardoc.org/), check out [yard-contracts](https://github.com/sfcgeorge/yard-contracts). It will automatically annotate your functions with contracts information. Instead of documenting each parameter for a function yourself, you can just add a contract and yard-contracts will generate the documentation for you!\r\n\r\n## Misc\r\n\r\nPlease submit any bugs [here](https://github.com/egonSchiele/contracts.ruby/issues) and I'll try to get them resolved ASAP!\r\n\r\nSee any mistakes in this tutorial? I try to make it bug-free, but they can creep in. [File an issue](https://github.com/egonSchiele/contracts.ruby/issues).\r\n\r\nIf you're using the library, please [let me know](https://github.com/egonSchiele) what project you're using it on :)\r\n\r\nSee the [wiki](https://github.com/egonSchiele/contracts.ruby/wiki) for more info.\r\n\r\nHappy Coding!","google":"UA-32498338-1","note":"Don't delete this file! It's used internally to help with page regeneration."}