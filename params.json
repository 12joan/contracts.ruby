{"name":"Contracts.ruby","tagline":"Contracts for Ruby","body":"# The contracts.ruby tutorial\r\n\r\n## Introduction\r\n\r\ncontracts.ruby brings code contracts to the Ruby language. Code contracts allow you make some assertions about your code, and then checks them to make sure they hold. This lets you\r\n\r\n- catch bugs faster\r\n- make it very easy to catch certain types of bugs\r\n- make sure that the user gets proper messaging when a bug occurs.\r\n\r\n## Installation\r\n\r\n    gem install contracts\r\n\r\n## Basics\r\n\r\nA simple example:\r\n\r\n```ruby\r\nContract Num, Num => Num\r\ndef add(a, b)\r\n  a + b\r\nend\r\n```\r\n\r\nHere, the contract is `Contract Num, Num => Num`. This says that the `add` function takes two numbers and returns a number.\r\n\r\nCopy this code into a file and run it:\r\n\r\n```ruby\r\nrequire 'contracts'\r\ninclude Contracts\r\n\r\nContract Num, Num => Num\r\ndef add(a, b)\r\n  a + b\r\nend\r\n\r\nputs add(1, \"foo\")\r\n```\r\n\r\nYou'll see a detailed error message like so:\r\n\r\n    ./contracts.rb:60:in `failure_callback': Contract violation: (RuntimeError)\r\n        Expected: Contracts::Num,\r\n        Actual: \"foo\"\r\n        Value guarded in: Object::add\r\n        With Contract: Contracts::Num, Contracts::Num\r\n        At: foo.rb:6\r\n\r\nThat tells you that your contract was violated! `add` expected a `Num`, and got a string (`\"foo\"`) instead.\r\nBy default, an exception is thrown when a contract fails. This can be changed to do whatever you want. More on this later.\r\n\r\nYou can also see the contract for a function with the `functype` method:\r\n\r\n    functype(:add)\r\n    => \"add :: Num, Num => Num\"\r\n\r\nThis can be useful if you're in a repl and want to figure out how a function should be used.\r\n\r\n## Builtin Contracts\r\n\r\n`Num` is one of the builtin contracts that contracts.ruby comes with. The builtin contracts are in the `Contracts` namespace. The easiest way to use them is to put `include Contracts` at the top of your file, but beware that they will pollute your namespace with new class names.\r\n\r\ncontracts.ruby comes with a lot of builtin contracts, including:\r\n\r\n    Num, Pos, Neg, Any, None, Or, Xor, And, Not, RespondTo, Send, Exactly, ArrayOf, HashOf, Bool, Maybe\r\n\r\nTo see all the builtin contracts and what they do, check out the [rdoc](http://rubydoc.info/gems/contracts/Contracts).\r\n\r\n## More Examples\r\n\r\n### Hello, World\r\n\r\n```ruby\r\nContract String => nil\r\ndef hello(name)\r\n  puts \"hello, #{name}!\"\r\nend\r\n```\r\n\r\nYou always need to specify a contract for the return value. In this example, `hello` doesn't return anything, so the contract is `nil`. Now you know that you can use a constant like `nil` as the end of a contract. Valid values for a contract are:\r\n\r\n- the name of a class (like `String` or `Fixnum`)\r\n- a constant (like `nil` or `1`)\r\n- a `Proc` that takes a value and returns true or false to indicate whether the contract passed or not\r\n- a class that responds to the `valid?` class method (more on this later)\r\n- an instance of a class that responds to the `valid?` method (more on this later)\r\n\r\n### A Double Function\r\n\r\n```ruby\r\nContract Or[Fixnum, Float] => Or[Fixnum, Float]\r\ndef double(x)\r\n  2 * x\r\nend\r\n```\r\n\r\nSometimes you want to be able to choose between a few contracts. `Or` takes a variable number of contracts and checks the argument against all of them. If it passes for any of the contracts, then the `Or` contract passes.\r\nThis introduces some new syntax. One of the valid values for a contract is an instance of a class that responds to the `valid?` method. This is what `Or[Fixnum, Float]` is. The longer way to write it would have been:\r\n\r\n```ruby\r\nContract Or.new(Fixnum, Float) => Or.new(Fixnum, Float)\r\n```\r\n\r\nAll the builtin contracts have overridden the square brackets (`[]`) to give the same functionality. So you could write\r\n\r\n```ruby\r\nContract Or[Fixnum, Float] => Or[Fixnum, Float]\r\n```\r\n\r\nor\r\n\r\n```ruby\r\nContract Or.new(Fixnum, Float) => Or.new(Fixnum, Float)\r\n```\r\n\r\nwhichever you prefer. They both mean the same thing here: make a new instance of `Or` with `Fixnum` and `Float`. Use that instance to validate the argument.\r\n\r\n### A Product Function\r\n\r\n```ruby\r\nContract ArrayOf[Num] => Num\r\ndef product(vals)\r\n  total = 1\r\n  vals.each do |val|\r\n    total *= val\r\n  end\r\n  total\r\nend\r\n```\r\n\r\nThis contract uses the `ArrayOf` contract. Here's how `ArrayOf` works: it takes a contract. It expects the argument to be a list. Then it checks every value in that list to see if it satisfies that contract.\r\n\r\n```ruby\r\n# passes\r\nproduct([1, 2, 3, 4])\r\n\r\n# fails\r\nproduct([1, 2, 3, \"foo\"])\r\n```\r\n\r\n### Another Product Function\r\n\r\n```ruby\r\nContract Args[Num] => Num\r\ndef product(*vals)\r\n  total = 1\r\n  vals.each do |val|\r\n    total *= val\r\n  end\r\n  total\r\nend\r\n```\r\n\r\nThis function uses varargs (`*args`) instead of an array. To make a contract on varargs, use the `Args` contract. It takes one contract as an argument and uses it to validate every element passed in through `*args`. So for example,\r\n\r\n`Args[Num]` means they should all be numbers.\r\n\r\n`Args[Or[Num, String]]` means they should all be numbers or strings.\r\n\r\n`Args[Any]` means all arguments are allowed (`Any` is a contract that passes for any argument).\r\n\r\n### Contracts On Arrays\r\n\r\nIf an array is one of the arguments and you know how many elements it's going to have, you can put a contract on it:\r\n\r\n```ruby\r\n# a function that takes an array of two elements...a person's age and a person's name.\r\nContract [Num, String] => nil\r\ndef person(data)\r\n  p data\r\nend\r\n```\r\n\r\nIf you don't know how many elements it's going to have, use `ArrayOf`.\r\n\r\n### Contracts On Hashes\r\n\r\nHere's a contract that requires a Hash. We can put contracts on each of the keys:\r\n\r\n```ruby\r\n# note the parentheses around the hash; without those you would get a syntax error\r\nContract ({ :age => Num, :name => String }) => nil\r\ndef person(data)\r\n  p data\r\nend\r\n```\r\n\r\nThen if someone tries to call the function with bad data, it will fail:\r\n\r\n```ruby\r\n# error: age can't be nil!\r\nperson({:name => \"Adit\", :age => nil})\r\n```\r\n\r\nYou don't need to put a contract on every key. So this call would succeed:\r\n\r\n```ruby\r\nperson({:name => \"Adit\", :age => 42, :foo => \"bar\"})\r\n```\r\n\r\neven though we don't specify a type for `:foo`.\r\n\r\nPeruse this contract on the keys and values of a Hash.\r\n\r\n```ruby\r\nContract HashOf[Symbol, Num] => Num\r\ndef give_largest_value(hsh)\r\n  hsh.values.max\r\nend\r\n```\r\nWhich you use like so:\r\n```ruby\r\n# succeeds\r\ngive_largest_value(a: 1, b: 2, c: 3) # returns 3\r\n\r\n# fails\r\ngive_largest_value(\"a\" => 1, 2 => 2, c: 3)\r\n```\r\n\r\n### Contracts On Functions\r\n\r\nIf you're writing higher-order functions (functions that take functions as parameters) and want to write a contract for the passed-in function, you can!\r\nUse the `Func` contract. `Func` takes a contract as it's argument, and uses that contract on the function that you pass in.\r\n\r\nHere's a `map` function that requires an array of numbers, and a function that takes a number and returns a number:\r\n\r\n```ruby\r\nContract ArrayOf[Num], Func[Num => Num] => ArrayOf[Num]\r\ndef map(arr, func)\r\n  ret = []\r\n  arr.each do |x|\r\n    ret << func[x]\r\n  end\r\n  ret\r\nend\r\n```\r\n\r\nThis will add the contract `Num => Num` on `func`. Try it with these two examples:\r\n\r\n```ruby\r\np map([1, 2, 3], lambda { |x| x + 1 }) # works\r\np map([1, 2, 3], lambda { |x| \"oops\" }) # fails, the lambda returns a string.\r\n```\r\n\r\n### Returning Multiple Values\r\nTreat the return value as an array. For example, here's a function that returns two numbers:\r\n\r\n```ruby\r\nContract Num => [Num, Num]\r\ndef mult(x)\r\n  return x, x+1\r\nend\r\n```\r\n\r\n## Synonyms For Contracts\r\n\r\nIf you use a contract a lot, it's a good idea to give it a meaningful synonym that tells the reader more about what your code returns. For example, suppose you have many functions that return a `Hash` or `nil`. If a `Hash` is returned, it contains information about a person. Your contact might look like this:\r\n\r\n```ruby\r\nContract String => Or[Hash, nil]\r\ndef some_func(str)\r\n```\r\n\r\nYou can make your contract more meaningful with a synonym:\r\n\r\n```ruby\r\n# the synonym\r\nPerson = Or[Hash, nil]\r\n\r\n# use the synonym here\r\nContract String => Person\r\ndef some_func(str)\r\n```\r\n\r\nNow you can use `Person` wherever you would have used `Or[Hash, nil]`. Your code is now cleaner and more clearly says what the function is doing.\r\n\r\n## Defining Your Own Contracts\r\n\r\nContracts are very easy to define. To re-iterate, there are 5 kinds of contracts:\r\n\r\n- the name of a class (like `String` or `Fixnum`)\r\n- a constant (like `nil` or `1`)\r\n- a `Proc` that takes a value and returns true or false to indicate whether the contract passed or not\r\n- a class that responds to the `valid?` class method (more on this later)\r\n- an instance of a class that responds to the `valid?` method (more on this later)\r\n\r\nThe first two don't need any extra work to define: you can just use any constant or class name in your contract and it should just work. Here are examples for the rest:\r\n\r\n### A Proc\r\n\r\n```ruby\r\nContract lambda { |x| x.is_a? Numeric } => Num\r\ndef double(x)\r\n```\r\n\r\nThe lambda takes one parameter: the argument that is getting passed to the function. It checks to see if it's a `Numeric`. If it is, it returns true. Otherwise it returns false.\r\nIt's not good practice to write a lambda right in your contract...if you find yourself doing it often, write it as a class instead:\r\n\r\n### A Class With `valid?` As a Class Method\r\n\r\nHere's how the `Num` class is defined. It does exactly what the `lambda` did in the previous example:\r\n\r\n```ruby\r\nclass Num\r\n  def self.valid? val\r\n    val.is_a? Numeric\r\n  end\r\nend\r\n```\r\n\r\nThe `valid?` class method takes one parameter: the argument that is getting passed to the function. It returns true or false.\r\n\r\n### A Class With `valid?` As an Instance Method\r\n\r\nHere's how the `Or` class is defined:\r\n\r\n```ruby\r\nclass Or < CallableClass\r\n  def initialize(*vals)\r\n    @vals = vals\r\n  end\r\n\r\n  def valid?(val)\r\n    @vals.any? do |contract|\r\n      res, _ = Contract.valid?(val, contract)\r\n      res\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThe `Or` contract takes a sequence of contracts, and passes if any of them pass. It uses `Contract.valid?` to validate the value against the contracts.\r\n\r\nThis class inherits from `CallableClass`, which allows us to use `[]` when using the class:\r\n\r\n```ruby\r\nContract Or[Fixnum, Float] => Num\r\ndef double(x)\r\n  2 * x\r\nend\r\n```\r\n\r\nWithout `CallableClass`, we would have to use `.new` instead:\r\n\r\n```ruby\r\nContract Or.new(Fixnum, Float) => Num\r\ndef double(x)\r\n# etc\r\n```\r\n\r\nYou can use `CallableClass` in your own contracts to make them callable using `[]`.\r\n\r\n## Customizing Error Messages\r\n\r\nWhen a contract fails, part of the error message prints the contract:\r\n\r\n    ...\r\n    Expected: Contracts::Num,\r\n    ...\r\n\r\nYou can customize this message by overriding the `to_s` method on your class or proc. For example, suppose we overrode `Num`'s `to_s` method:\r\n\r\n```ruby\r\ndef Num.to_s\r\n  \"a number please\"\r\nend\r\n```\r\n\r\nNow the error says:\r\n\r\n    ...\r\n    Expected: a number please,\r\n    ...\r\n\r\n## Failure Callbacks\r\n\r\nSupposing you don't want contract failures to become exceptions. You run a popular website, and when there's a contract exception you would rather log it and continue than throw an exception and break your site.\r\n\r\ncontracts.ruby provides a failure callback that gets called when a contract fails. For example, here we log every failure instead of raising an error:\r\n\r\n```ruby\r\nContract.override_failure_callback do |data|\r\n  puts \"You had an error\"\r\n  puts failure_msg(data)\r\nend\r\n```\r\n\r\n`failure_msg` is a function that prints out information about the failure. Your failure callback gets a hash with the following values:\r\n\r\n    {\r\n      :arg => the argument to the method,\r\n      :contract => the contract that got violated,\r\n      :class => the method's class,\r\n      :method => the method,\r\n      :contracts => the contract object\r\n    }\r\n\r\nIf your failure callback returns `false`, the method that the contract is guarding will not be called (the default behaviour).\r\n\r\n## Disabling contracts\r\n\r\nIf you want to disable contracts, set the `NO_CONTRACTS` environment variable. This will disable contracts completely and you won't have a performance hit.\r\n\r\n## Method overloading\r\n\r\nYou can use contracts for method overloading! For example, here's a factorial function without method overloading:\r\n\r\n```ruby\r\nContract Num => Num\r\ndef fact x\r\n  if x == 1\r\n    x\r\n  else\r\n    x * fact(x - 1)\r\n  end\r\nend\r\n```\r\n\r\nHere it is again, re-written with method overloading:\r\n\r\n```ruby\r\nContract 1 => 1\r\ndef fact x\r\n  x\r\nend\r\n\r\nContract Num => Num\r\ndef fact x\r\n  x * fact(x - 1)\r\nend\r\n```\r\n\r\nFor an argument, each function will be tried in order. The first function that doesn't raise a `ContractError` will be used. So in this case, if x == 1, the first function will be used. For all other values, the second function will be used.\r\n\r\n## Contracts in modules\r\n\r\nTo use contracts on module you need to include both `Contracts` and `Contracts::Modules` into it:\r\n\r\n```ruby\r\nmodule M\r\n  include Contracts\r\n  include Contracts::Modules\r\n\r\n  Contract String => String\r\n  def self.parse\r\n    # do some hard parsing\r\n  end\r\n```\r\n\r\n## Invariants\r\n\r\nInvariants are conditions on objects that should always hold. If after any method call on given object, any of the Invariants fails, then Invariant violation error will be generated.\r\n\r\n**NOTE**: Only methods with contracts will be affected.\r\n\r\nA simple example:\r\n\r\n```ruby\r\nclass MyBirthday < Struct.new(:day, :month)\r\n  include Contracts\r\n  include Contracts:Invariants\r\n\r\n  Invariant(:day) { 1 <= day && day <= 31 }\r\n  Invariant(:month) { 1 <= month && month <= 12 }\r\n\r\n  Contract None => Fixnum\r\n  def silly_next_day!\r\n    self.day += 1\r\n  end\r\nend\r\n\r\nbirthday = MyBirthday.new(31, 12)\r\nbirthday.silly_next_day!\r\n```\r\n\r\nIf you run it, last line will generate invariant violation:\r\n\r\n```ruby\r\n./invariant.rb:38:in `failure_callback': Invariant violation: (RuntimeError)\r\n   Expected: day condition to be true\r\n   Actual: false\r\n   Value guarded in: MyBirthday::silly_next_day!\r\n   At: main.rb:9\r\n```\r\n\r\nWhich means, that after `#silly_next_day!` all checks specified in `Invariant` statement will be verified, and if at least one fail, then Invariant violation error will be raised.\r\n\r\n## Misc\r\n\r\nPlease submit any bugs [here](https://github.com/egonSchiele/contracts.ruby/issues) and I'll try to get them resolved ASAP!\r\n\r\nSee any mistakes in this tutorial? I try to make it bug-free, but they can creep in. [File an issue](https://github.com/egonSchiele/contracts.ruby/issues).\r\n\r\nIf you're using the library, please [let me know](https://github.com/egonSchiele) what project you're using it on :)\r\n\r\nSee the [wiki](https://github.com/egonSchiele/contracts.ruby/wiki) for more info.\r\n\r\nHappy Coding!","google":"UA-32498338-1","note":"Don't delete this file! It's used internally to help with page regeneration."}